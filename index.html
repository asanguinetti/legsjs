<!DOCTYPE html>

<html>

<head>
  <title>Creature Demo - Axel Sanguinetti</title>
  
  <script type="text/javascript" src="js/three.js"></script>
  <script type="text/javascript" src="js/cannon.js"></script>
  <script type="text/javascript" src="js/ammo.js"></script>
  <script type="text/javascript" src="js/bodies.js"></script>
  
  <script type="text/javascript">
  
  'use strict';
  
  // Function declarations
  var addVisual;
  var initScene;
  var updatePhysics;
  var updateVisuals;
  var updateMuscleVisual;
  var updateMuscleLength;
  var createGround;
  var createTrunk;
  var createBone;
  var createFrontLeg
  var createBackLeg;
  var animate;
  var respectJoints;
  var onTouchStart;
  var onMouseMove;
  var onKeyDown;
  var onMouseWheel;
  var updateCamera;

  // Internal objects
  var scene;

  var DebugDrawer = function() {
    var wrappedFrom;
    var wrappedTo;
    var wrappedColor;
    var line;

    this.debugMode = 0 | (1 << 11) | (1 << 12);
    this.objIndex = 0;
    this.objects = [];
    for(var i = 0; i < 1500; i++)
    {
      this.objects.push(new THREE.Line(new THREE.Geometry(), 
                                       new THREE.LineBasicMaterial({color: new THREE.Color()})));
      this.objects[i].geometry.vertices.push(new THREE.Vector3());
      this.objects[i].geometry.vertices.push(new THREE.Vector3());
    }
    this.btDebugDrawer = new Ammo.DebugDraw();
    this.btDebugDrawer.userData = this;
    this.btDebugDrawer.drawLine = function(from, to, color) {
      wrappedFrom = Ammo.wrapPointer(from, Ammo.btVector3);
      wrappedTo = Ammo.wrapPointer(to, Ammo.btVector3);
      wrappedColor = Ammo.wrapPointer(color, Ammo.btVector3);

      line = this.userData.objects[this.userData.objIndex++];
      line.material.color.setRGB(wrappedColor.x(), wrappedColor.y(), wrappedColor.z());
      line.geometry.vertices[0].set(wrappedFrom.x(), wrappedFrom.y(), wrappedFrom.z());
      line.geometry.vertices[1].set(wrappedTo.x(), wrappedTo.y(), wrappedTo.z());
      line.geometry.verticesNeedUpdate = true;

      scene.add(line);
    };
    this.btDebugDrawer.drawContactPoint = function(PointOnB, normalOnB, distance, lifeTime, color) {
      // TODO: implement
    };
    this.btDebugDrawer.reportErrorWarning = function(warningString) {
      console.log(warningString);
    };
    this.btDebugDrawer.draw3dText = function(location, textString) {
      // TODO: implement
    };
    this.btDebugDrawer.setDebugMode = function(debugMode) {
      this.userData.debugMode = debugMode;
    };
    this.btDebugDrawer.getDebugMode = function() {
      return this.userData.debugMode;
    };
  };

  DebugDrawer.prototype.clear = function() {
    this.objIndex = 0;
  };

  createFrontLeg = function(mass) {
    var leg = {};

    leg.upper = new Bone(mass, new THREE.Vector3(0.2, 0.2, 1.0));
    leg.upper.translate(0, 0, -leg.upper.size.z);

    leg.middle = new Bone(mass, new THREE.Vector3(0.2, 0.2, 1.0));
    leg.middle.translate(0, 0, -leg.middle.size.z);
    leg.middle.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 8);

    leg.lower = new Foot(mass, new THREE.Vector3(0.2, 0.2, 0.5));
    leg.lower.translate(0, 0, -leg.lower.size.z);
    leg.lower.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 8);

    leg.upperMiddleMuscle = new Muscle(leg.upper,
                                       new THREE.Vector3(0, leg.upper.size.y, 0),
                                       leg.middle,
                                       new THREE.Vector3(0, leg.middle.size.y, 0),
                                       0.93*(leg.upper.size.z + leg.middle.size.z),
                                       0.05*(leg.upper.size.z + leg.middle.size.z),
                                       0);

    leg.middleLowerMuscle = new Muscle(leg.middle,
                                       new THREE.Vector3(0, leg.middle.size.y, 0),
                                       leg.lower,
                                       new THREE.Vector3(0, leg.lower.size.y, 0),
                                       0.93*(leg.middle.size.z + leg.lower.size.z),
                                       0.03*(leg.middle.size.z + leg.lower.size.z),
                                       0);

    leg.muscles = [];
    leg.muscles.push(leg.upperMiddleMuscle);
    leg.muscles.push(leg.middleLowerMuscle);

    var leftAxis = new Ammo.btVector3(1, 0, 0);
    leg.constraints = [];
    leg.constraints.push(new Ammo.btHingeConstraint(leg.upper.body,
                                                    leg.middle.body,
                                                    new Ammo.btVector3(0, 0, -leg.upper.size.z),
                                                    new Ammo.btVector3(0, 0, leg.middle.size.z),
                                                    leftAxis,
                                                    leftAxis));
    leg.constraints.push(new Ammo.btHingeConstraint(leg.middle.body,
                                                    leg.lower.body,
                                                    new Ammo.btVector3(0, 0, -leg.middle.size.z),
                                                    new Ammo.btVector3(0, 0, leg.lower.size.z),
                                                    leftAxis,
                                                    leftAxis));

    return leg;
  }

  createBackLeg = function(mass) {
    var leg = {};

    leg.upper = new Bone(mass, new THREE.Vector3(0.2, 0.2, 1.0));
    leg.upper.translate(0, 0, -leg.upper.size.z);

    leg.middle = new Bone(mass, new THREE.Vector3(0.2, 0.2, 1.0));
    leg.middle.translate(0, 0, -leg.middle.size.z);
    leg.middle.rotateAxis(new THREE.Vector3(1, 0, 0), -2*Math.PI / 8);

    leg.lower = new Foot(mass, new THREE.Vector3(0.2, 0.2, 1.0));
    leg.lower.translate(0, 0, -leg.lower.size.z);
    leg.lower.rotateAxis(new THREE.Vector3(1, 0, 0), 2*Math.PI / 8);

    leg.upperMiddleMuscle = new Muscle(leg.upper,
                                       new THREE.Vector3(0, -leg.upper.size.y, 0),
                                       leg.middle,
                                       new THREE.Vector3(0, -leg.middle.size.y, 0),
                                       0.7*(leg.upper.size.z + leg.middle.size.z),
                                       0.2*(leg.upper.size.z + leg.middle.size.z),
                                       0);

    leg.middleLowerMuscle = new Muscle(leg.middle,
                                       new THREE.Vector3(0, leg.middle.size.y, 0),
                                       leg.lower,
                                       new THREE.Vector3(0, leg.lower.size.y, 0),
                                       0.7*(leg.middle.size.z + leg.lower.size.z),
                                       0.2*(leg.middle.size.z + leg.lower.size.z),
                                       0);

    leg.muscles = [];
    leg.muscles.push(leg.upperMiddleMuscle);
    leg.muscles.push(leg.middleLowerMuscle);

    var leftAxis = new Ammo.btVector3(1, 0, 0);
    leg.constraints = [];
    leg.constraints.push(new Ammo.btHingeConstraint(leg.upper.body,
                                                    leg.middle.body,
                                                    new Ammo.btVector3(0, 0, -leg.upper.size.z),
                                                    new Ammo.btVector3(0, 0, leg.middle.size.z),
                                                    leftAxis,
                                                    leftAxis));
    leg.constraints.push(new Ammo.btHingeConstraint(leg.middle.body,
                                                    leg.lower.body,
                                                    new Ammo.btVector3(0, 0, -leg.middle.size.z),
                                                    new Ammo.btVector3(0, 0, leg.lower.size.z),
                                                    leftAxis,
                                                    leftAxis));
    return leg;
  }

  respectJoints = function(leg, legPoint, trunk, trunkPoint) {
    leg.upper.snapTo(legPoint, trunk, trunkPoint);

    leg.middle.snapTo(new THREE.Vector3(0, 0, leg.middle.size.z), 
                      leg.upper, 
                      new THREE.Vector3(0, 0, -leg.upper.size.z));

    leg.lower.snapTo(new THREE.Vector3(0, 0, leg.lower.size.z), 
                     leg.middle, 
                     new THREE.Vector3(0, 0, -leg.middle.size.z));
  }
  
  initScene = function() {
    scene = new THREE.Scene();

    scene.renderer = new THREE.WebGLRenderer({ antialias: true });
    scene.renderer.setClearColor( 0xeeeeff, 1);
    scene.renderer.setSize( window.innerWidth, window.innerHeight );
    scene.renderer.shadowMapEnabled = true;
    scene.renderer.shadowMapSoft = true;
    document.getElementById( 'viewport' ).appendChild( scene.renderer.domElement );
    scene.renderer.domElement.addEventListener('touchstart', onTouchStart);
    scene.renderer.domElement.addEventListener('touchmove', onMouseMove);
    scene.renderer.domElement.addEventListener("mousewheel", onMouseWheel, false);
    scene.renderer.domElement.addEventListener("DOMMouseScroll", onMouseWheel, false);
    scene.renderer.domElement.addEventListener('mousemove', onMouseMove);
    window.addEventListener("keydown", onKeyDown);

    scene.info = document.createElement( 'div' );
    scene.info.style.position = 'absolute';
    scene.info.style.top = '10px';
    scene.info.style.width = '100%';
    scene.info.style.textAlign = 'center';
    scene.info.innerHTML = '<h1>Press \'1\' to toggle muscle rendering</h1>';
    document.getElementById( 'viewport' ).appendChild( scene.info );

    scene.camera = new THREE.PerspectiveCamera(
      35,
      window.innerWidth / window.innerHeight,
      1,
      1000
    );
    scene.camera.position.set( 60, 60, 50 );
    scene.camera.up.set(0,0,1);
    scene.camera.lookAt( scene.position );
    scene.add( scene.camera );
    
    // Light
    var light = new THREE.DirectionalLight( 0xFFFFFF );
    light.position.set( -15, 20, 40 );
    light.target.position.copy( scene.position );
    light.castShadow = true;
    light.shadowCameraLeft = -60;
    light.shadowCameraTop = -60;
    light.shadowCameraRight = 60;
    light.shadowCameraBottom = 60;
    light.shadowCameraNear = 20;
    light.shadowCameraFar = 200;
    light.shadowBias = -.0005
    light.shadowMapWidth = light.shadowMapHeight = 2048;
    light.shadowDarkness = .7;
    scene.add( light );

    var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    var overlappingPairCache = new Ammo.btDbvtBroadphase();
    var solver = new Ammo.btSequentialImpulseConstraintSolver();
    scene.debugDrawer = new DebugDrawer();
    scene.world = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    scene.world.setDebugDrawer(scene.debugDrawer.btDebugDrawer);
    scene.world.setGravity(new Ammo.btVector3(0,0,-10));

    scene.world.bodies = [];

    /* ground */
    var ground = new Ground(new THREE.Vector3(50, 50, 0.5));
    ground.buildAndInsert(scene);

    /* trunk */
    var mass = 1;
    var trunk = new Trunk(mass, new THREE.Vector3(3.5, 5, 2.5));
    trunk.translate(0, 0, 10);
    trunk.buildAndInsert(scene);
    scene.camera.target = trunk;

    var legs = [];
    var legFL = createFrontLeg(mass);
    legFL.upper.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 8);
    legFL.middle.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 8 + Math.PI / 16);
    legFL.lower.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 4);
    respectJoints(legFL, 
                  new THREE.Vector3(0, 0, legFL.upper.size.z),
                  trunk, 
                  new THREE.Vector3(-trunk.size.x, trunk.size.y, -trunk.size.z));
    legs.push(legFL);

    var legFR = createFrontLeg(mass);
    legFR.upper.rotateAxis(new THREE.Vector3(1, 0, 0), -Math.PI / 8);
    legFR.middle.rotateAxis(new THREE.Vector3(1, 0, 0), -Math.PI / 8);
    respectJoints(legFR, 
                  new THREE.Vector3(0, 0, legFL.upper.size.z),
                  trunk, 
                  new THREE.Vector3(trunk.size.x, trunk.size.y, -trunk.size.z));
    legs.push(legFR);

    var legRL = createBackLeg(mass);
    respectJoints(legRL, 
                  new THREE.Vector3(0, 0, legFL.upper.size.z),
                  trunk, 
                  new THREE.Vector3(-trunk.size.x, -trunk.size.y, -trunk.size.z));
    legs.push(legRL);

    var legRR = createBackLeg(mass);
    legRR.upper.rotateAxis(new THREE.Vector3(1, 0, 0), Math.PI / 8);
    respectJoints(legRR, 
                  new THREE.Vector3(0, 0, legFL.upper.size.z),
                  trunk, 
                  new THREE.Vector3(trunk.size.x, -trunk.size.y, -trunk.size.z));
    legs.push(legRR);

    legFL.upperMiddleMuscle.phase = -Math.PI/2;
    legFR.upperMiddleMuscle.phase = Math.PI/2;
    legRL.upperMiddleMuscle.phase = -Math.PI/2-Math.PI/4+Math.PI/8;
    legRR.upperMiddleMuscle.phase = Math.PI/2-Math.PI/4+Math.PI/8;

    legFL.middleLowerMuscle.phase = -Math.PI/2;
    legFR.middleLowerMuscle.phase = Math.PI/2;
    legRL.middleLowerMuscle.phase = -Math.PI/2-Math.PI/4+Math.PI/8;
    legRR.middleLowerMuscle.phase = Math.PI/2-Math.PI/4+Math.PI/8;

    var muscles = [];
    var orig = new THREE.Vector3(0, 0, 0);

    var trunkLegFLMuscle = new Muscle(trunk, orig, legFL.upper, 
                                      new THREE.Vector3(0, -legFL.upper.size.y, 0),
                                      7, 0.3, Math.PI/2);
    muscles.push(trunkLegFLMuscle);

    var trunkLegFRMuscle = new Muscle(trunk, orig, legFR.upper, 
                                      new THREE.Vector3(0, -legFR.upper.size.y, 0),
                                      7, 0.3, -Math.PI/2);
    muscles.push(trunkLegFRMuscle);

    var trunkLegRLMuscle = new Muscle(trunk, orig, legRL.upper, 
                                      new THREE.Vector3(0, legRL.upper.size.y, 0),
                                      6.75, 0.5, -Math.PI/2+Math.PI/4);
    muscles.push(trunkLegRLMuscle);

    var trunkLegRRMuscle = new Muscle(trunk, orig, legRR.upper, 
                                      new THREE.Vector3(0, legRL.upper.size.y, 0),
                                      6.75, 0.5, Math.PI/2+Math.PI/4);
    muscles.push(trunkLegRRMuscle);

    // Constrain legs
    var constraints = [];
    var leftAxis = new Ammo.btVector3(1, 0, 0);

    legs.forEach(function(leg) {
      leg.upper.buildAndInsert(scene);
      leg.middle.buildAndInsert(scene);
      leg.lower.buildAndInsert(scene);

      constraints.push(new Ammo.btHingeConstraint(leg.upper.body,
                                                  leg.middle.body,
                                                  new Ammo.btVector3(0, 0, -leg.upper.size.z),
                                                  new Ammo.btVector3(0, 0, leg.middle.size.z),
                                                  leftAxis,
                                                  leftAxis));
      constraints.push(new Ammo.btHingeConstraint(leg.middle.body,
                                                  leg.lower.body,
                                                  new Ammo.btVector3(0, 0, -leg.middle.size.z),
                                                  new Ammo.btVector3(0, 0, leg.lower.size.z),
                                                  leftAxis,
                                                  leftAxis));
    });

    constraints.push(new Ammo.btHingeConstraint(trunk.body, 
                                                legFL.upper.body,
                                                new Ammo.btVector3(-trunk.size.x, trunk.size.y, -trunk.size.z),
                                                new Ammo.btVector3(0, 0, legFL.upper.size.z),
                                                leftAxis,
                                                leftAxis));
    constraints.push(new Ammo.btHingeConstraint(trunk.body, 
                                                legFR.upper.body,
                                                new Ammo.btVector3(trunk.size.x, trunk.size.y, -trunk.size.z),
                                                new Ammo.btVector3(0, 0, legFR.upper.size.z),
                                                leftAxis,
                                                leftAxis));
    constraints.push(new Ammo.btHingeConstraint(trunk.body, 
                                                legRL.upper.body,
                                                new Ammo.btVector3(-trunk.size.x, -trunk.size.y, -trunk.size.z),
                                                new Ammo.btVector3(0, 0, legRL.upper.size.z),
                                                leftAxis,
                                                leftAxis));
    constraints.push(new Ammo.btHingeConstraint(trunk.body, 
                                                legRR.upper.body,
                                                new Ammo.btVector3(trunk.size.x, -trunk.size.y, -trunk.size.z),
                                                new Ammo.btVector3(0, 0, legRR.upper.size.z),
                                                leftAxis,
                                                leftAxis));

    for( var i = 0; i < legs.length; i++ )
      muscles = muscles.concat(legs[i].muscles);

    muscles.forEach(function(muscle) {
      muscle.buildAndInsert(scene);
    });

    /* sets a callback for updating the muscles */
    scene.showMuscles = false;
    var fp = Ammo.Runtime.addFunction(function(world, timeStep) {
      muscles.forEach(function(muscle) {
        muscle.update(timeStep, scene.showMuscles);
      });
    });

    scene.world.setInternalTickCallback(fp);

    for(var i=0; i<constraints.length; i++) {
      scene.world.addConstraint(constraints[i], true);
    }

    animate();
  };

  onKeyDown = function(event) {
    if( event.key !== 'undefined' && event.key == '1' ||
        event.keyCode == 49 )
      scene.showMuscles = !scene.showMuscles;
  }

  var pinchDist = 0;
  onTouchStart = function(event) {
    if (typeof event == 'undefined')
      event = window.event;
    
    if (event.touches){
      if(event.touches.length == 2) {
        pinchDist = vec2.distance([event.touches[0].pageX, 
                                   event.touches[0].pageY], 
                                  [event.touches[1].pageX, 
                                   event.touches[1].pageY]);
        event.preventDefault();
      }
    }
  }

  var inclination = Math.PI/4;
  var azimuth = 0;
  var yaw = 0;
  var pitch = 0;
  onMouseMove = function(event) {
    var x;
    var y;

    if (typeof event == 'undefined')
      event = window.event;
    
    event.preventDefault();

    if ( event.changedTouches ) {
      if(event.touches.length == 2) {
        /* it's a pinch to zoom gesture */
        newDist = vec2.distance([event.touches[0].pageX, 
                                 event.touches[0].pageY], 
                                [event.touches[1].pageX, 
                                 event.touches[1].pageY]);
        zoom += (pinchDist - newDist);
        pinchDist = newDist;
        zoom = Math.max(0, Math.min(zoom, 80));
        return;
      }
      event = event.changedTouches[0];
    }
      
    if(event.clientX) {
        x = event.clientX+document.body.scrollLeft;
        y = event.clientY+document.body.scrollTop;
    } else if(event.pageX) {
        x = event.pageX+window.pageXOffset;
        y = event.pageY+window.pageYOffset;
    }

    /* azimuth goes from -PI to PI as the cursor's X goes from left to right */
    azimuth = x * 2 * Math.PI / window.innerWidth - Math.PI;

    /* inclination goes from PI/2 to 0 as the cursor's Y goes from top to bottom"*/
    inclination = (window.innerHeight - y) * Math.PI / (2*window.innerHeight);

    /* azimuth will work for yaw since it goes from -PI to PI */
    yaw = azimuth;

    /* we need pitch to go from PI/2 to -PI/2 as Y goes from top to bottom */
    pitch = (window.innerHeight - y) * Math.PI / (window.innerHeight) - Math.PI/2;
  }

  var zoom = 50;
  onMouseWheel = function(event) {
    /* cross-browser wheel delta */
    var event = window.event || event; /* IE */
    var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));
    zoom += delta;
    zoom = Math.max(0, Math.min(zoom, 80));
  }

  var cameraPosMat = new THREE.Matrix4();
  var m1 = new THREE.Matrix4();
  var m2 = new THREE.Matrix4();
  var m3 = new THREE.Matrix4();
  updateCamera = function()
  {
    /* start with the camera at the origin */
    scene.camera.position.copy( scene.position );

    /* rotates the camera position around the Z axis for the azimuth */
    m1.makeRotationZ(azimuth);

    /* raises the camera rotating around the X axis for the inclination */
    m2.makeRotationX(-inclination);

    /* moves the camera away from the center */
    m3.makeTranslation(0, -zoom, 0);

    cameraPosMat.multiplyMatrices( m1, m2 );
    cameraPosMat.multiply( m3 );

    /* applies the transformation to the camera position */
    scene.camera.position.applyMatrix4(cameraPosMat);
    scene.camera.position.add(scene.camera.target.visual.position);
    scene.camera.lookAt(scene.camera.target.visual.position);
  }

  var time_last = Date.now();
  var time_delta = 0;
  updatePhysics = function() {
      /* steps world */
      time_delta = Date.now() - time_last;
      scene.world.stepSimulation(time_delta / 1000.0, 1500, 0.005);
      time_last += time_delta;
  }

  updateVisuals = function() {
    /* Read position data into visuals */
    scene.world.bodies.forEach( function(b) {
      b.updateVisual();
    } );
    scene.world.debugDrawWorld();
    scene.debugDrawer.clear();
  }
  
  animate = function() {
    requestAnimationFrame( animate );
    updateCamera();
    updateVisuals();
    updatePhysics();
    scene.renderer.clear();
    scene.renderer.render( scene, scene.camera );
  }

  window.onload = initScene;
  
  </script>
</head>

<body>
  <div id="viewport"></div>
</body>

</html>