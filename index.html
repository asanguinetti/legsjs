<!DOCTYPE html>

<html>

<head>
  <title>Creature Demo - Axel Sanguinetti</title>
  
  <script type="text/javascript" src="/js/three.js"></script>
  <script type="text/javascript" src="/js/cannon.js"></script>
  <script type="text/javascript" src="/js/ammo.js"></script>
  
  <script type="text/javascript">
  
  'use strict';
  
  // Function declarations
  var shape2mesh;
  var addVisual;
  var initScene;
  var updatePhysics;
  var updateVisuals;
  var updateMuscleVisual;
  var updateMuscleLength;
  var createGround;
  var createTrunk;
  var createBone;
  var createFrontLeg
  var createBackLeg;
  var animate;
  var respectJoints;
  var onTouchStart;
  var onMouseMove;
  var onKeyDown;
  var onMouseWheel;
  var updateCamera;

  // Internal objects
  var scene;

  addVisual = function(scene, body, material, geometry){
    var mesh = new THREE.Mesh( geometry, material );
    mesh.receiveShadow = true;
    mesh.castShadow = true;

    body.visualref = new THREE.Object3D();
    body.visualref.add(mesh);

    scene.add(body.visualref);
  };

  updateMuscleVisual = function(muscle) {
    var p = muscle.bodyA.position.vadd(muscle.bodyB.position).scale(0.5);
    var dir = muscle.bodyA.position.vsub(muscle.bodyB.position).unit();
    var q = new CANNON.Quaternion();
    muscle.visualref.scale.y = muscle.distance;
    q.setFromVectors(new CANNON.Vec3(0, 1, 0), dir);
    muscle.visualref.position.set(p.x, p.y, p.z);
    muscle.visualref.quaternion.set(q.x, q.y, q.z, q.w);

    /* computes the color of the muscle */
    var r = (muscle.distance - muscle.midLength) / muscle.delta;
    muscle.visualref.material.color = new THREE.Color( 1, 0.5 - 0.2*r, 0.5 - 0.2*r );

    muscle.visualref.visible = scene.showMuscles;
  }

  updateMuscleLength = function(muscle, wt) {
    muscle.distance = muscle.midLength + muscle.delta * Math.sin(wt + muscle.phase);
  }

  createGround = function() {
    var localInertia = new Ammo.btVector3(0, 0, 0);
    var shape = new Ammo.btBoxShape(new Ammo.btVector3(50, 50, 0.5));
    var motionState = new Ammo.btDefaultMotionState();
    var rbInfo = new Ammo.btRigidBodyConstructionInfo(0, motionState, shape, localInertia);
    return new Ammo.btRigidBody(rbInfo);
  }

  createTrunk = function(mass, pos, dimensions) {
    var localInertia = new Ammo.btVector3(0, 0, 0);

    var t = new Ammo.btTransform();
    t.setIdentity();
    t.setOrigin(new Ammo.btVector3(0, 0, 10));

    var motionState = new Ammo.btDefaultMotionState(t);

    var trunkShape = new Ammo.btCompoundShape(true);
    var dir = new Ammo.btVector3(dimensions[0], 0, -dimensions[2]);
    var shoulderLength = 0.5 * dir.length();
    var backboneShape = new Ammo.btBoxShape(new Ammo.btVector3(0.2, dimensions[1], 0.2));
    var shoulderShape = new Ammo.btBoxShape(new Ammo.btVector3(0.2, shoulderLength, 0.2));

    t.setIdentity();
    trunkShape.addChildShape(t, backboneShape);

    var q = new Ammo.btQuaternion();
    // q.setEulerZYX(0, Math.atan2(-dir.z(), dir.x()), Math.PI/2);
    // t.setRotation(q);
    t.setOrigin(new Ammo.btVector3(0.5*dir.x(),dimensions[1],0.5*dir.z()));
    trunkShape.addChildShape(t, shoulderShape);

    // q.setEulerZYX(0, Math.atan2(-dir.z(), -dir.x()), Math.PI/2);
    // t.setRotation(q);
    t.setOrigin(new Ammo.btVector3(-0.5*dir.x(),dimensions[1],0.5*dir.z()));
    trunkShape.addChildShape(t, shoulderShape);

    // q.setEulerZYX(0, Math.atan2(-dir.z(), dir.x()), Math.PI/2);
    // t.setRotation(q);
    t.setOrigin(new Ammo.btVector3(0.5*dir.x(),-dimensions[1],0.5*dir.z()));
    trunkShape.addChildShape(t, shoulderShape);

    // q.setEulerZYX(0, Math.atan2(-dir.z(), -dir.x()), Math.PI/2);
    // t.setRotation(q);
    t.setOrigin(new Ammo.btVector3(-0.5*dir.x(),-dimensions[1],0.5*dir.z()));
    trunkShape.addChildShape(t, shoulderShape);

    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, trunkShape, localInertia);
    var trunk = new Ammo.btRigidBody(rbInfo);

    return trunk;
  }

  createBone = function(mass, pos, dimensions) {
    var localInertia = new Ammo.btVector3(0, 0, 0);

    var t = new Ammo.btTransform();
    t.setIdentity();
    t.setOrigin(new Ammo.btVector3(pos[0], pos[1], pos[2]));

    var motionState = new Ammo.btDefaultMotionState(t);

    var shape = new Ammo.btBoxShape(new Ammo.btVector3(dimensions[0], dimensions[1], dimensions[2]));

    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, trunkShape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);

    var mesh = new THREE.Mesh( new THREE.BoxGeometry( dimensions[0], dimensions[1], dimensions[2] ), 
                               new THREE.MeshLambertMaterial( { color: 0x66a5ff } ) );
    mesh.receiveShadow = true;
    mesh.castShadow = true;

    body.visualref = new THREE.Object3D();
    body.visualref.add(mesh);

    return body;
  }

  createFrontLeg = function(mass, material) {
    var leg = {};

    leg.upper = new CANNON.Body({mass: mass, material: material});
    leg.upper.size = new CANNON.Vec3(0.2, 0.2, 1.0);
    leg.upper.addShape(new CANNON.Box(leg.upper.size.scale(0.9)));
    leg.upper.position.z -= leg.upper.size.z;

    leg.middle = new CANNON.Body({mass: mass, material: material});
    leg.middle.size = new CANNON.Vec3(0.2, 0.2, 1.0);
    leg.middle.addShape(new CANNON.Box(leg.middle.size.scale(0.9)));
    leg.middle.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 8);
    var dst = leg.upper.pointToWorldFrame(new CANNON.Vec3(0, 0, -leg.upper.size.z));
    var src = leg.middle.pointToWorldFrame(new CANNON.Vec3(0, 0, leg.middle.size.z));
    leg.middle.position.copy(leg.middle.position.vadd(dst.vsub(src)));

    leg.lower = new CANNON.Body({mass: mass, material: material});
    leg.lower.size = new CANNON.Vec3(0.2, 0.2, 0.5);
    leg.lower.addShape(new CANNON.Box(leg.lower.size.scale(0.9)));
    leg.lower.addShape(new CANNON.Sphere(0.9*leg.lower.size.x), 
                       new CANNON.Vec3(0,0,-leg.lower.size.z - leg.lower.size.x));
    leg.lower.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 8);
    dst = leg.middle.pointToWorldFrame(new CANNON.Vec3(0, 0, -leg.middle.size.z));
    src = leg.lower.pointToWorldFrame(new CANNON.Vec3(0, 0, leg.lower.size.z));
    leg.lower.position.copy(leg.lower.position.vadd(dst.vsub(src)));

    leg.upperMiddleMuscle = new CANNON.DistanceConstraint( leg.upper, 
                                                           leg.middle, 
                                                           0.93 * (leg.upper.size.z + leg.middle.size.z) );
    leg.upperMiddleMuscle.midLength = leg.upperMiddleMuscle.distance;
    leg.upperMiddleMuscle.delta = leg.upperMiddleMuscle.midLength * 0.05;

    leg.middleLowerMuscle = new CANNON.DistanceConstraint( leg.middle, 
                                                           leg.lower, 
                                                           1 * (leg.middle.size.z + leg.lower.size.z) );
    leg.middleLowerMuscle.midLength = leg.middleLowerMuscle.distance;
    leg.middleLowerMuscle.delta = leg.middleLowerMuscle.midLength * 0.03;

    leg.muscles = [];
    leg.muscles.push(leg.upperMiddleMuscle);
    leg.muscles.push(leg.middleLowerMuscle);

    var leftAxis = new CANNON.Vec3(1,0,0);
    leg.constraints = [];
    leg.constraints.push(new CANNON.HingeConstraint(leg.upper, leg.middle, { pivotA: new CANNON.Vec3( 0, 0, -leg.upper.size.z ), axisA: leftAxis,  pivotB: new CANNON.Vec3( 0, 0, leg.middle.size.z ), axisB: leftAxis, collideConnected: false }));
    leg.constraints.push(new CANNON.HingeConstraint(leg.middle, leg.lower, { pivotA: new CANNON.Vec3( 0, 0, -leg.middle.size.z ), axisA: leftAxis,  pivotB: new CANNON.Vec3( 0, 0, leg.lower.size.z ), axisB: leftAxis, collideConnected: false }));

    return leg;
  }

  createBackLeg = function(mass, material) {
    var leg = {};

    leg.upper = new CANNON.Body({mass: mass, material: material});
    leg.upper.size = new CANNON.Vec3(0.2, 0.2, 1.0);
    leg.upper.addShape(new CANNON.Box(leg.upper.size.scale(0.9)));
    leg.upper.position.z -= leg.upper.size.z;

    leg.middle = new CANNON.Body({mass: mass, material: material});
    leg.middle.size = new CANNON.Vec3(0.2, 0.2, 1.0);
    leg.middle.addShape(new CANNON.Box(leg.middle.size.scale(0.9)));
    leg.middle.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -2*Math.PI / 8);
    var dst = leg.upper.pointToWorldFrame(new CANNON.Vec3(0, 0, -leg.upper.size.z));
    var src = leg.middle.pointToWorldFrame(new CANNON.Vec3(0, 0, leg.middle.size.z));
    leg.middle.position.copy(leg.middle.position.vadd(dst.vsub(src)));

    leg.lower = new CANNON.Body({mass: mass, material: material});
    leg.lower.size = new CANNON.Vec3(0.2, 0.2, 1.0);
    leg.lower.addShape(new CANNON.Box(leg.lower.size.scale(0.9)));
    leg.lower.addShape(new CANNON.Sphere(0.9*leg.lower.size.x), 
                       new CANNON.Vec3(0,0,-leg.lower.size.z - leg.lower.size.x));
    leg.lower.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 2*Math.PI / 8);
    dst = leg.middle.pointToWorldFrame(new CANNON.Vec3(0, 0, -leg.middle.size.z));
    src = leg.lower.pointToWorldFrame(new CANNON.Vec3(0, 0, leg.lower.size.z));
    leg.lower.position.copy(leg.lower.position.vadd(dst.vsub(src)));

    leg.upperMiddleMuscle = new CANNON.DistanceConstraint( leg.upper, 
                                                           leg.middle, 
                                                           0.7 * (leg.upper.size.z + leg.middle.size.z));
    leg.upperMiddleMuscle.midLength = leg.upperMiddleMuscle.distance;
    leg.upperMiddleMuscle.delta = leg.upperMiddleMuscle.midLength * 0.2;

    leg.middleLowerMuscle = new CANNON.DistanceConstraint( leg.middle, 
                                                           leg.lower, 
                                                           0.7 * (leg.middle.size.z + leg.lower.size.z) );
    leg.middleLowerMuscle.midLength = leg.middleLowerMuscle.distance;
    leg.middleLowerMuscle.delta = leg.middleLowerMuscle.midLength * 0.2;

    leg.muscles = [];
    leg.muscles.push(leg.upperMiddleMuscle);
    leg.muscles.push(leg.middleLowerMuscle);

    var leftAxis = new CANNON.Vec3(1,0,0);
    leg.constraints = [];
    leg.constraints.push(new CANNON.HingeConstraint(leg.upper, leg.middle, { pivotA: new CANNON.Vec3( 0, 0, -leg.upper.size.z ), axisA: leftAxis,  pivotB: new CANNON.Vec3( 0, 0, leg.middle.size.z ), axisB: leftAxis, collideConnected: false }));
    leg.constraints.push(new CANNON.HingeConstraint(leg.middle, leg.lower, { pivotA: new CANNON.Vec3( 0, 0, -leg.middle.size.z ), axisA: leftAxis,  pivotB: new CANNON.Vec3( 0, 0, leg.lower.size.z ), axisB: leftAxis, collideConnected: false }));

    return leg;
  }

  respectJoints = function(leg, jointPos) {
    leg.upper.position.copy(jointPos);
    leg.upper.position.z -= leg.upper.size.z;

    var dst = leg.upper.pointToWorldFrame(new CANNON.Vec3(0, 0, -leg.upper.size.z));
    var src = leg.middle.pointToWorldFrame(new CANNON.Vec3(0, 0, leg.middle.size.z));
    leg.middle.position.copy(leg.middle.position.vadd(dst.vsub(src)));

    dst = leg.middle.pointToWorldFrame(new CANNON.Vec3(0, 0, -leg.middle.size.z));
    src = leg.lower.pointToWorldFrame(new CANNON.Vec3(0, 0, leg.lower.size.z));
    leg.lower.position.copy(leg.lower.position.vadd(dst.vsub(src)));
  }
  
  initScene = function() {
    scene = new THREE.Scene();

    scene.renderer = new THREE.WebGLRenderer({ antialias: true });
    scene.renderer.setClearColor( 0xeeeeff, 1);
    scene.renderer.setSize( window.innerWidth, window.innerHeight );
    scene.renderer.shadowMapEnabled = true;
    scene.renderer.shadowMapSoft = true;
    document.getElementById( 'viewport' ).appendChild( scene.renderer.domElement );
    scene.renderer.domElement.addEventListener('touchstart', onTouchStart);
    scene.renderer.domElement.addEventListener('touchmove', onMouseMove);
    scene.renderer.domElement.addEventListener("mousewheel", onMouseWheel, false);
    scene.renderer.domElement.addEventListener("DOMMouseScroll", onMouseWheel, false);
    scene.renderer.domElement.addEventListener('mousemove', onMouseMove);
    window.addEventListener("keydown", onKeyDown);

    scene.info = document.createElement( 'div' );
    scene.info.style.position = 'absolute';
    scene.info.style.top = '10px';
    scene.info.style.width = '100%';
    scene.info.style.textAlign = 'center';
    scene.info.innerHTML = '<h1>Press \'1\' to toggle muscle rendering</h1>';
    document.getElementById( 'viewport' ).appendChild( scene.info );

    scene.camera = new THREE.PerspectiveCamera(
      35,
      window.innerWidth / window.innerHeight,
      1,
      1000
    );
    scene.camera.position.set( 60, 60, 50 );
    scene.camera.up.set(0,0,1);
    scene.camera.lookAt( scene.position );
    scene.add( scene.camera );
    
    // Light
    var light = new THREE.DirectionalLight( 0xFFFFFF );
    light.position.set( -15, 20, 40 );
    light.target.position.copy( scene.position );
    light.castShadow = true;
    light.shadowCameraLeft = -60;
    light.shadowCameraTop = -60;
    light.shadowCameraRight = 60;
    light.shadowCameraBottom = 60;
    light.shadowCameraNear = 20;
    light.shadowCameraFar = 200;
    light.shadowBias = -.0001
    light.shadowMapWidth = light.shadowMapHeight = 2048;
    light.shadowDarkness = .7;
    scene.add( light );

    var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    var overlappingPairCache = new Ammo.btDbvtBroadphase();
    var solver = new Ammo.btSequentialImpulseConstraintSolver();
    scene.world = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    scene.world.setGravity(new Ammo.btVector3(0,0,-20));

    scene.world.bodies = [];

    // Materials
    // var groundMaterial = new CANNON.Material("groundMaterial");
    // groundMaterial.color = 0xeeeeee;
    // var boneMaterial = new CANNON.Material("boneMaterial");
    // boneMaterial.color = 0x66a5ff;
    // var bodyMaterial = new CANNON.Material("bodyMaterial");
    // bodyMaterial.color = 0xff6666;
    // var legGroundContactMaterial = new CANNON.ContactMaterial(groundMaterial,
    //                                                           boneMaterial, 
    //                                                           { friction: 0.3, restitution: 0.3 });
    // scene.world.addContactMaterial(legGroundContactMaterial);
    
    /* ground */
    var ground = createGround();
    scene.world.addRigidBody(ground);
    scene.world.bodies.push(ground);
    addVisual(scene, ground, new THREE.MeshLambertMaterial({color: 0xeeeeee}),
                             new THREE.BoxGeometry( 50, 50, 0.5 ));

    /* trunk */
    var mass = 2;
    var trunk = createTrunk(mass, [0, 0, 10], [3.5, 5, 2.5]);
    scene.world.addRigidBody(trunk);
    scene.world.bodies.push(trunk);
    addVisual(scene, trunk, new THREE.MeshLambertMaterial({color: 0x66a5ff}),
                            new THREE.BoxGeometry( 3.5, 5, 2.5 ));

    var legs = [];
    // var legFL = createFrontLeg(mass, boneMaterial);
    // respectJoints(legFL, new CANNON.Vec3(bodyDimensions.x, 
    //                                      bodyDimensions.y,
    //                                      trunk.position.z - bodyDimensions.z));
    // legs.push(legFL);
    // var legFR = createFrontLeg(mass, boneMaterial);
    // legFR.upper.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 8);
    // legFR.middle.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), 0);
    // respectJoints(legFR, new CANNON.Vec3(-bodyDimensions.x, 
    //                                      bodyDimensions.y,
    //                                      trunk.position.z - bodyDimensions.z));
    // legs.push(legFR);
    // var legRL = createBackLeg(mass, boneMaterial);
    // respectJoints(legRL, new CANNON.Vec3(bodyDimensions.x, 
    //                                      -bodyDimensions.y,
    //                                      trunk.position.z - bodyDimensions.z));
    // legs.push(legRL);
    // var legRR = createBackLeg(mass, boneMaterial);
    // legRR.upper.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 8);
    // respectJoints(legRR, new CANNON.Vec3(-bodyDimensions.x, 
    //                                      -bodyDimensions.y,
    //                                      trunk.position.z - bodyDimensions.z));
    // legs.push(legRR);

    // legFL.upperMiddleMuscle.phase = -Math.PI/2;
    // legFR.upperMiddleMuscle.phase = Math.PI/2;
    // legRL.upperMiddleMuscle.phase = -Math.PI/2-Math.PI/4-Math.PI/8;
    // legRR.upperMiddleMuscle.phase = Math.PI/2-Math.PI/4-Math.PI/8;

    // legFL.middleLowerMuscle.phase = -Math.PI/2;
    // legFR.middleLowerMuscle.phase = Math.PI/2;
    // legRL.middleLowerMuscle.phase = -Math.PI/2-Math.PI/4-Math.PI/8;
    // legRR.middleLowerMuscle.phase = Math.PI/2-Math.PI/4-Math.PI/8;


    var muscles = [];
    // var trunkLegFLMuscle = new CANNON.DistanceConstraint( trunk, legFL.upper, 8 );
    // trunkLegFLMuscle.midLength = 7;
    // trunkLegFLMuscle.delta = 0.3;
    // trunkLegFLMuscle.phase = Math.PI/2;
    // muscles.push(trunkLegFLMuscle);
    // var trunkLegFRMuscle = new CANNON.DistanceConstraint( trunk, legFR.upper, 8 );
    // trunkLegFRMuscle.midLength = 7;
    // trunkLegFRMuscle.delta = 0.3;
    // trunkLegFRMuscle.phase = -Math.PI/2;
    // muscles.push(trunkLegFRMuscle);
    // var trunkLegRLMuscle = new CANNON.DistanceConstraint( trunk, legRL.upper, 6 );
    // trunkLegRLMuscle.midLength = 6.75;
    // trunkLegRLMuscle.delta = 0.5;
    // trunkLegRLMuscle.phase = -Math.PI/2+Math.PI/4;
    // muscles.push(trunkLegRLMuscle);
    // var trunkLegRRMuscle = new CANNON.DistanceConstraint( trunk, legRR.upper, 6 );
    // trunkLegRRMuscle.midLength = 6.75;
    // trunkLegRRMuscle.delta = 0.5;
    // trunkLegRRMuscle.phase = Math.PI/2+Math.PI/4;
    // muscles.push(trunkLegRRMuscle);

    for( var i = 0; i < legs.length; i++ )
      muscles = muscles.concat(legs[i].muscles);

    scene.showMuscles = false;

    for( var i = 0; i < muscles.length; i++ )
    {
      var muscle = muscles[i];
      var mesh = new THREE.Mesh(
        new THREE.CylinderGeometry( 0.1, 0.1, 1.0 ),
        new THREE.MeshLambertMaterial( { color: 0xff8888 } )
      );
      muscle.visualref = mesh;
      scene.add(mesh);
      updateMuscleVisual(muscle);
    }

    var omega = 0.5;
    // scene.world.addEventListener("preStep",function(event){
    //     for( i in muscles ) {
    //       updateMuscleLength(muscles[i], omega*this.time)
    //       updateMuscleVisual(muscles[i]);
    //     }
    // });

    // Constrain legs
    var constraints = [];
    // var leftAxis = new CANNON.Vec3(1,0,0);
    // constraints.push(new CANNON.HingeConstraint(trunk, legFL.upper,  { pivotA: new CANNON.Vec3( bodyDimensions.x, bodyDimensions.y, -bodyDimensions.z ), axisA: leftAxis,  pivotB: new CANNON.Vec3( 0, 0, legFL.upper.size.z ), axisB: leftAxis, collideConnected: false }));
    // constraints.push(new CANNON.HingeConstraint(trunk, legFR.upper, { pivotA: new CANNON.Vec3( -bodyDimensions.x, bodyDimensions.y, -bodyDimensions.z ), axisA: leftAxis, pivotB: new CANNON.Vec3( 0, 0, legFR.upper.size.z ), axisB: leftAxis, collideConnected: false }));
    // constraints.push(new CANNON.HingeConstraint(trunk, legRL.upper,   { pivotA: new CANNON.Vec3( bodyDimensions.x, -bodyDimensions.y, -bodyDimensions.z ), axisA: leftAxis, pivotB: new CANNON.Vec3( 0, 0, legRL.upper.size.z ), axisB: leftAxis, collideConnected: false }));
    // constraints.push(new CANNON.HingeConstraint(trunk, legRR.upper,  { pivotA: new CANNON.Vec3( -bodyDimensions.x, -bodyDimensions.y, -bodyDimensions.z ), axisA: leftAxis, pivotB: new CANNON.Vec3( 0, 0, legRR.upper.size.z ), axisB: leftAxis, collideConnected: false }));

    for( var i = 0; i < legs.length; i++ )
      constraints = constraints.concat(legs[i].constraints);

    for( var i = 0; i < muscles.length; i++ )
      scene.world.addConstraint(muscles[i]);

    for(var i=0; i<constraints.length; i++) {
      scene.world.addConstraint(constraints[i]);
    }

    animate();
  };

  onKeyDown = function(event) {
    if( event.key !== 'undefined' && event.key == '1' ||
        event.keyCode == 49 )
      scene.showMuscles = !scene.showMuscles;
  }

  var pinchDist = 0;
  onTouchStart = function(event) {
    if (typeof event == 'undefined')
      event = window.event;
    
    if (event.touches){
      if(event.touches.length == 2) {
        pinchDist = vec2.distance([event.touches[0].pageX, 
                                   event.touches[0].pageY], 
                                  [event.touches[1].pageX, 
                                   event.touches[1].pageY]);
        event.preventDefault();
      }
    }
  }

  var inclination = Math.PI/4;
  var azimuth = 0;
  var yaw = 0;
  var pitch = 0;
  onMouseMove = function(event) {
    var x;
    var y;

    if (typeof event == 'undefined')
      event = window.event;
    
    event.preventDefault();

    if ( event.changedTouches ) {
      if(event.touches.length == 2) {
        /* it's a pinch to zoom gesture */
        newDist = vec2.distance([event.touches[0].pageX, 
                                 event.touches[0].pageY], 
                                [event.touches[1].pageX, 
                                 event.touches[1].pageY]);
        zoom += (pinchDist - newDist);
        pinchDist = newDist;
        zoom = Math.max(0, Math.min(zoom, 80));
        return;
      }
      event = event.changedTouches[0];
    }
      
    if(event.clientX) {
        x = event.clientX+document.body.scrollLeft;
        y = event.clientY+document.body.scrollTop;
    } else if(event.pageX) {
        x = event.pageX+window.pageXOffset;
        y = event.pageY+window.pageYOffset;
    }

    /* azimuth goes from -PI to PI as the cursor's X goes from left to right */
    azimuth = x * 2 * Math.PI / window.innerWidth - Math.PI;

    /* inclination goes from PI/2 to 0 as the cursor's Y goes from top to bottom"*/
    inclination = (window.innerHeight - y) * Math.PI / (2*window.innerHeight);

    /* azimuth will work for yaw since it goes from -PI to PI */
    yaw = azimuth;

    /* we need pitch to go from PI/2 to -PI/2 as Y goes from top to bottom */
    pitch = (window.innerHeight - y) * Math.PI / (window.innerHeight) - Math.PI/2;
  }

  var zoom = 50;
  onMouseWheel = function(event) {
    /* cross-browser wheel delta */
    var event = window.event || event; /* IE */
    var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));
    zoom += delta;
    zoom = Math.max(0, Math.min(zoom, 80));
  }

  var cameraPosMat = new THREE.Matrix4();
  var m1 = new THREE.Matrix4();
  var m2 = new THREE.Matrix4();
  var m3 = new THREE.Matrix4();
  updateCamera = function()
  {
    /* start with the camera at the origin */
    scene.camera.position.copy( scene.position );

    /* rotates the camera position around the Z axis for the azimuth */
    m1.makeRotationZ(azimuth);

    /* raises the camera rotating around the X axis for the inclination */
    m2.makeRotationX(-inclination);

    /* moves the camera away from the center */
    m3.makeTranslation(0, -zoom, 0);

    cameraPosMat.multiplyMatrices( m1, m2 );
    cameraPosMat.multiply( m3 );

    /* applies the transformation to the camera position */
    scene.camera.position.applyMatrix4(cameraPosMat);
    scene.camera.lookAt( scene.position );
  }

  var time_last = Date.now();
  var time_delta = 0;
  updatePhysics = function() {
      // Step world
      time_delta = Date.now() - time_last;
      scene.world.stepSimulation(time_delta / 1000.0, 5);
      time_last += time_delta;
  }

  var trans = new Ammo.btTransform();
  updateVisuals = function() {
    // Read position data into visuals
    scene.world.bodies.forEach( function(b) {
      if( b.getMotionState() && b.visualref !== undefined ) {
        b.getMotionState().getWorldTransform(trans);

        b.visualref.position.set(trans.getOrigin().x(), 
                                 trans.getOrigin().y(), 
                                 trans.getOrigin().z());
        b.visualref.quaternion.set(trans.getRotation().w(), 
                                   trans.getRotation().x(), 
                                   trans.getRotation().y(), 
                                   trans.getRotation().z());
      }
    } );
  }
  
  animate = function() {
    requestAnimationFrame( animate );
    updateCamera();
    updateVisuals();
    updatePhysics();
    scene.renderer.clear();
    scene.renderer.render( scene, scene.camera );
  }

  window.onload = initScene;
  
  </script>
</head>

<body>
  <div id="viewport"></div>
</body>

</html>